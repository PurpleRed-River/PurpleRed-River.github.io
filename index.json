[{"categories":["笔记"],"content":"前言 2020 MIT公开课:The Missing Semester of Your CS Education(计算机教育中缺失的一课) 官方 github 仓库:https://github.com/missing-semester/missing-semester 2020 讲义:https://missing.csail.mit.edu/ 2020 中文讲义:https://missing-semester-cn.github.io/ 2019 讲义:https://missing.csail.mit.edu/2019/ 感谢课程制作者和 刘黑黑a 的翻译上传。 我的笔记基本是课程内容和讲义的二次整理，方便自己查看。 Shell 工具和脚本 Shell 基于空格分割命令并进行解析。如果传递的参数中包含空格，使用单引号，双引号，或使用转义符号 \\ 。 在 Shell 中执行 date 或 echo 时，Shell 通过环境变量来找到程序并执行。也就是说 Shell 是一个编程环境，它实际具备变量、条件、循环和函数等。 Shell 查看环境变量 echo $PATH。 查看程序路径 which echo。 Shell 中的路径是一组被分割的目录，在 Linux 和 macOS 上使用 / 分割，而在Windows上是 \\。 pwd 获取当前目录路径。 cd 切换目录，. 当前目录， .. 上级目录。 ls 打印当前目录下的文件 mv 用于重命名或移动文件 cp 拷贝文件 mkdir 新建文件夹 在 Shell 中，程序有两个主要的“流”：它们的输入流和输出流。 最简单的重定向是 \u003c 和 \u003e。还可以使用 \u003e\u003e 来向一个文件追加内容，使用管道 | 操作符，我们能够更好的利用文件重定向。 在 Bash 中为变量赋值的语法是 foo=bar，访问变量中存储的数值，其语法为 $foo。 Bash 中的字符串通过 ' 和 \" 分隔符来定义，但是它们的含义并不相同。 ' 定义的字符串为原义字符串，其中的变量不会被转义 \" 定义的字符串会将变量值进行替换。 Bash 支持 if, case, while 和 for 这些控制流关键字。 Bash 支持函数，它可以接受参数并基于参数进行操作。与其他脚本语言不同的是，bash使用了很多特殊的变量来表示参数、错误代码和相关变量。下面是列举来其中一些变量，更完整的列表可以参考 高级 Bash 脚本编写指南：第三章特殊字符。 $0 - 脚本名 $1 到 $9 - 脚本的参数。 $1 是第一个参数，依此类推。 $@ - 所有参数 $# - 参数个数 $? - 前一个命令的返回值 $$ - 当前脚本的进程识别码 !! - 完整的上一条命令，包括参数。常见应用：当你因为权限不足执行命令失败时，可以使用 sudo !!再尝试一次。 $_ - 上一条命令的最后一个参数。如果你正在使用的是交互式 shell，你可以通过按下 Esc 之后键入 . 来获取这个值。 命令通常使用 STDOUT 来返回输出值，使用 STDERR 来返回错误及错误码。 返回码或退出状态是脚本/命令之间交流执行状态的方式。返回值0表示正常执行，其他所有非0的返回值都表示有错误发生。 退出码可以搭配 \u0026\u0026（与操作符）和 ||（或操作符）使用，用来进行条件判断，决定是否执行其他程序。同一行的多个命令可以用 ; 分隔。程序 true 的返回码永远是 0，false 的返回码永远是 1。 另一个常见的模式是以变量的形式获取一个命令的输出，这可以通过命令替换（command substitution）实现。 $(CMD) 这样的方式来执行CMD 这个命令时，它的输出结果会替换掉 $(CMD)。 在 Bash 中进行比较时，尽量使用双方括号 [[ ]] 而不是单方括号 [ ] 通配符 - 当你想要利用通配符进行匹配时，你可以分别使用 ? 和 * 来匹配一个或任意个字符。 花括号 {} - 当你有一系列的指令，其中包含一段公共子串时，可以用花括号来自动展开这些命令。 shell函数和脚本有如下一些不同点： 函数只能与shell使用相同的语言，脚本可以使用任意语言。因此在脚本中包含 shebang 是很重要的。 函数仅在定义时被加载，脚本会在每次被执行时加载。这让函数的加载比脚本略快一些，但每次修改函数定义，都要重新加载一次。 函数会在当前的shell环境中执行，脚本会在单独的进程中执行。因此，函数可以对环境变量进行更改，比如改变当前工作目录，脚本则不行。脚本需要使用 export 将环境变量导出，并将值传递给环境变量。 与其他程序语言一样，函数可以提高代码模块性、代码复用性并创建清晰性的结构。shell脚本中往往也会包含它们自己的函数定义。 ","date":"2023-07-04","objectID":"/missing-semester-note-1/:0:0","tags":["学习"],"title":"计算机教育中缺失的一课 笔记一","uri":"/missing-semester-note-1/"},{"categories":["笔记"],"content":"命令行基本工具 shellcheck 定位sh/bash脚本中的错误。 TLDR pages 它提供了一些命令案例，帮助快速找到正确的选项。 find 它是 shell 上用于查找文件的绝佳工具。 # 查找所有名称为src的文件夹 find . -name src -type d # 查找所有文件夹路径中包含test的python文件 find . -path '*/test/*.py' -type f # 查找前一天修改的所有文件 find . -mtime -1 # 查找所有大小在500k至10M的tar.gz文件 find . -size +500k -size -10M -name '*.tar.gz' # 删除全部扩展名为.tmp 的文件 find . -name '*.tmp' -exec rm {} \\; # 查找全部的 PNG 文件并将其转换为 JPG find . -name '*.png' -exec convert {} {}.jpg \\; fd 就是一个更简单、更快速、更友好的查找程序，它可以用来作为find的替代品。输出着色、默认支持正则匹配、支持unicode并且我认为它的语法更符合直觉。 locate 使用一个由 updatedb负责更新的数据库，通过编译索引或建立数据库的方式来实现更加快速地搜索。在大多数系统中 updatedb 都会通过 cron 每日更新。find 和类似的工具可以通过别的属性比如文件大小、修改时间或是权限来查找文件，locate则只能通过文件名。 grep 有很多选项，这也使它成为一个非常全能的工具。其中经常使用的有 -C ：获取查找结果的上下文（Context）；-v 将对结果进行反选（Invert），也就是输出不匹配的结果。举例来说， grep -C 5 会输出匹配结果前后五行。当需要搜索大量文件的时候，使用 -R 会递归地进入子目录并搜索所有的文本文件。 ack, ag 和 rg 都是 grep 的替代品，比较常用的是 ripgrep (rg) ，速度快，而且用法符合直觉。 # 查找所有使用了 requests 库的文件 rg -t py 'import requests' # 查找所有没有写 shebang 的文件（包含隐藏文件） rg -u --files-without-match \"^#!\" # 查找所有的foo字符串，并打印其之后的5行 rg foo -A 5 # 打印匹配的统计信息（匹配的行和文件的数量） rg --stats PATTERN history 命令允许您以程序员的方式来访问shell中输入的历史命令。 对于大多数的 Shell 来说，您可以使用 Ctrl+R 对命令历史记录进行回溯搜索。敲 Ctrl+R 后您可以输入子串来进行匹配，查找历史命令行。zsh 支持直接方向键上、下，同时 zsh 还支持基于历史的自动补全，非常方便。 你可以修改 shell history 的行为，例如，如果在命令的开头加上一个空格，它就不会被加进 Shell 记录中。当你输入包含密码或是其他敏感信息的命令时会用到这一特性。 为此你需要在 .bashrc 中添加 HISTCONTROL=ignorespace 或者向 .zshrc 添加 setopt HIST_IGNORE_SPACE。 如果你不小心忘了在前面加空格，可以通过编辑。bash_history 或 .zhistory 来手动地从历史记录中移除那一项。 fzf 是一个通用对模糊查找工具，它可以和很多命令一起使用。 fasd和 autojump 这两个工具来查找最常用或最近使用的文件和目录。 Fasd 基于 frecency 对文件和文件排序，也就是说它会同时针对频率（frequency）和时效（recency）进行排序。默认情况下，fasd使用命令 z 帮助我们快速切换到最常访问的目录。 还有一些更复杂的工具可以用来概览目录结构，例如 tree, broot 或更加完整的文件管理器，例如 nnn 或 ranger。 xargs 命令传递参数的一个过滤器，也是组合多个命令的一个工具。它能够捕获一个命令的输出，然后传递给另外一个命令。有时候您要利用数据整理技术从一长串列表里找出你所需要安装或移除的东西。我们之前讨论的相关技术配合 xargs 即可实现。之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令。 命令格式 somecommand |xargs -item command ","date":"2023-07-04","objectID":"/missing-semester-note-1/:1:0","tags":["学习"],"title":"计算机教育中缺失的一课 笔记一","uri":"/missing-semester-note-1/"},{"categories":["笔记"],"content":"数据分析相关工具 less 文件分页器 less 为我们创建来一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。 sed 流编辑器 sed 是一个基于文本编辑器 ed 构建的”流编辑器” 。在 sed 中，可以利用一些简短的命令来修改文件，而不是直接操作文件的内容。最常用的是 s 替换命令。sed 可以搭配其他命令，完成一些数据的处理。例如 cat server.log | grep sshd | grep \"Disconnected from\" | sed 's/.*Disconnected from //' 通过 grep 过滤最后使用 sed 匹配正则表达式完成了一次输出。 sed 还可以做很多各种各样有趣的事情，例如文本注入：(使用 i 命令)，打印特定的行 (使用 p 命令)，基于索引选择特定行等等。 关于 sed 的更多使用，可以通过 Sed 备忘清单 了解。 正则表达式（RegEX） 正则表达式非常常见也非常有用，值得您花些时间去理解它。 . 除换行符之外的”任意单个字符” * 匹配前面字符零次或多次 + 匹配前面字符一次或多次 [abc] 匹配 a, b 和 c 中的任意一个 (RX1|RX2) 任何能够匹配RX1 或 RX2的结果 ^ 行首 $ 行尾 sed 使用正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加 \\ 才能使其具有特殊含义。或者，您也可以添加 -E 选项来支持这些匹配。 正则表达式是出了名的难以写对，但是它仍然会是您强大的常备工具之一。我在此不准备写更多关于正则表达式的用例。下面列出来一些非常有用的网站。 正则表达式在线调试工具regex debugger RegExp Example 正则实例大全 RegEX 备忘清单 awk 用于文本处理的编程语言 Awk、sed与grep，俗称Linux下的三剑客，它们之间有很多相似点，但是同样也各有各的特色，相似的地方是它们都可以匹配文本，其中sed和awk还可以用于文本编辑，而grep则不具备这个功用。sed是一种非交互式且面向字符流的编辑器（a “non-interactive” stream-oriented editor），而awk则是一门模式匹配的编程语言，因为它的主要功能是用于匹配文本并处理，同时它有一些编程语言才有的语法，例如函数、分支循环语句、变量等等，当然比起我们常见的编程语言，Awk相对比较简单。 语法 awk [选项参数] 'script' var=value file(s) 或 awk [选项参数] -f scriptfile var=value file(s)，例子：每行按空格或TAB分割，输出文本中的1、4项 awk '{print $1,$4}' log.txt。 在代码块中，$0 表示整行的内容，$1 到 $n 为一行中的 n 个区域，区域的分割基于 awk 的域分隔符（默认是空格，可以通过 -F 来修改）。 更多内容可以看 菜鸟教程 和 Awk 备忘清单。 sort 数据排序、uniq 次数统计、head 查看开头、tail 查看内容、paste 合并列、bc 计算器 ssh myserver journalctl | grep sshd # 筛选 | grep \"Disconnected from\" | sed -E 's/.*Disconnected from (invalid |authenticating )?user (.*) [^ ]+ port [0-9]+( \\[preauth\\])?$/\\2/' | sort | uniq -c # sort 会对其输入数据进行排序。 # uniq -c 会把连续出现的行折叠为一行并使用出现次数作为前缀。 # 这句最终是按照出现次数排序，过滤出最常出现的用户名 | sort -nk1,1 | tail -n10 # sort -n 会按照数字顺序对输入进行排序 # 默认情况下是按照字典序排序 -k1,1 则表示“仅基于以空格分割的第一列进行排序” # n 部分表示“仅排序到第n个部分”，默认情况是到行尾。 # tail -n10 表示从尾部显示十行，也就是次数多的 | awk '{print $2}' | paste -sd, # awk 对于每一行文本，打印其第二个部分，也就是用户名。 # paste 以 ',' 分隔，将用户名放到一行 | paste -sd+ | bc -l # paste 将一列数字用 '+' 分隔放到一行，然后 bc 执行 R语言 R 也是一种编程语言，它非常适合被用来进行数据分析和绘制图表。这里我们不会讲的特别详细， 您只需要知道summary 可以打印某个向量的统计结果。我们将输入的一系列数据存放在一个向量后，利用R语言就可以得到我们想要的统计数据。 gnuplot 二维曲线绘图工具 整理二进制数据 虽然到目前为止我们的讨论都是基于文本数据，但对于二进制文件其实同样有用。例如我们可以用 ffmpeg 从相机中捕获一张图片，将其转换成灰度图后通过SSH将压缩后的文件发送到远端服务器，并在那里解压、存档并显示。 ffmpeg -loglevel panic -i /dev/video0 -frames 1 -f image2 - | convert - -colorspace gray - | gzip | ssh mymachine 'gzip -d | tee copy.jpg | env DISPLAY=:0 feh -' 编辑器（Vim） 写作和写代码其实是两项非常不同的活动。当我们编程的时候，会经常在文件间进行切换、阅读、浏览和修改代码，而不是连续编写一大段的文字。因此代码编辑器和文本编辑器是很不同的两种工具。 ","date":"2023-07-04","objectID":"/missing-semester-note-1/:2:0","tags":["学习"],"title":"计算机教育中缺失的一课 笔记一","uri":"/missing-semester-note-1/"},{"categories":["笔记"],"content":"Vim 的哲学——多模态编辑 多模态编辑，插入文字、操纵文字有不同模式，Vim 接口本身就是一种程序语言可以进行编程，键入操作（以及他们的助记名） 本身是命令，这些命令可以组合使用。这使得移动和编辑更加高效。 Vim 会维护一系列打开的文件，称为**“缓存”。一个 Vim 会话包含一系列标签页**，每个标签页包含 一系列窗口（分隔面板）。每个窗口显示一个缓存。但值得注意的是，“缓存”和“窗口”之间不是对应关系，窗口只是其中一个视角，我们可以打开多个窗口显示同一个缓存。 模式 作用 备注 正常模式（默认） 在文件中四处移动光标进行修改 \u003cESC\u003e 回到正常模式 插入模式 插入文本 i 进入 替换模式 替换文本 R 进入 可视化模式（一般，行，块） 选中文本块 v 一般、V 行、\u003cC-v\u003e 块 命令模式 用于执行命令 : 进入 在不同模式下，按键的含义也不同，一般当前的模式会显示在左下角。 ","date":"2023-07-04","objectID":"/missing-semester-note-1/:3:0","tags":["学习"],"title":"计算机教育中缺失的一课 笔记一","uri":"/missing-semester-note-1/"},{"categories":["笔记"],"content":"Vim 命令 除了以下课程上提到的操作之外我推荐 Vim 备忘清单 命令行模式 :q 退出（关闭窗口） :w 保存（写） :wq 保存然后退出 :e {文件名} 打开要编辑的文件 :ls 显示打开的缓存 :help {标题} 打开帮助文档 :help :w 打开 :w 命令的帮助文档 :help w 打开 w 移动的帮助文档 移动 **基本移动： *h``j``k``l （左， 下， 上， 右） 词： w （下一个词）， b （词初）， e （词尾） 行： 0 （行初）， ^ （第一个非空格字符）， $ （行尾） 屏幕： H （屏幕首行）， M （屏幕中间）， L （屏幕底部） 翻页： Ctrl-u （上翻）， Ctrl-d （下翻） 文件： gg （文件头）， G （文件尾） 行数： :{行数}\u003cCR\u003e 或者 {行数}G ({行数}为行数) 杂项： % （找到配对，比如括号或者 / */ 之类的注释对） 查找： f{字符}， t{字符}， F{字符}， T{字符} 查找/到 向前/向后 在本行的{字符} ,/; 用于导航匹配 **搜索: **/{正则表达式}, n/N 用于导航匹配 编辑 i 进入插入模式 O/o 在之上/之下插入行 d{移动命令} 删除 {移动命令} 例如，dw 删除词, d$ 删除到行尾, d0 删除到行头。 c{移动命令} 改变 {移动命令} 例如，cw 改变词 比如 d{移动命令} 再 i x 删除字符（等同于 dl） s 替换字符（等同于 xi） 可视化模式 + 操作 选中文字, d 删除 或者 c 改变 u 撤销, \u003cC-r\u003e 重做 y 复制 / “yank” （其他一些命令比如 d 也会复制） p 粘贴 ~ 改变字符的大小写 可视化模式下的选择 可视化：v 可视化行：V 可视化块：Ctrl+v 使用移动命令选中 计数使用 所有你需要用鼠标做的事， 你现在都可以用键盘：采用编辑命令和移动命令的组合来完成。 这就是 Vim 的界面开始看起来像一个程序语言的时候。Vim 的编辑命令也被称为 “动词”， 因为动词可以施动于名词。下面是一些例子，通过结合使用，来指定操作多次。 3w 向前移动三个词 5j 向下移动5行 7dw 删除7个词 使用修饰语 你可以用修饰语改变“名词”的意义。 修饰语有 i，表示**“内部”或者“在内”，和 a， 表示“周围”**。 ci( 改变当前括号内的内容 ci[ 改变当前方括号内的内容 da' 删除一个单引号字符串， 包括周围的单引号 进阶操作：搜索与替换 :s （替换）命令（文档）。 %s/foo/bar/g 在整个文件中将 foo 全局替换成 bar %s/[._]((._))/\\1/g 将有命名的 Markdown 链接替换成简单 URLs 进阶操作：多窗口 用 :sp/:vsp 来分割窗口 同一个缓存可以在多个窗口中显示。 进阶操作：宏 q{字符} 来开始在寄存器{字符}中录制宏 q 停止录制 @{字符} 重放宏，宏的执行遇错误会停止 {计数}@{字符} 执行一个宏{计数}次 @@ 重复上一个宏 ","date":"2023-07-04","objectID":"/missing-semester-note-1/:4:0","tags":["学习"],"title":"计算机教育中缺失的一课 笔记一","uri":"/missing-semester-note-1/"},{"categories":["笔记"],"content":"配置文件与扩展插件 ","date":"2023-07-04","objectID":"/missing-semester-note-1/:5:0","tags":["学习"],"title":"计算机教育中缺失的一课 笔记一","uri":"/missing-semester-note-1/"},{"categories":["笔记"],"content":"自定义你的 Vim —— 从配置文件开始 Vim 由一个位于 ~/.vimrc 的文本配置文件，如果没有就新建一个即可。Vim 能够被重度自定义，花时间探索自定义选项是值得的。可以参考其他人的在 GitHub 上共享的配置文件。例如下面是三位授课人的配置文件，但尽量在阅读后加入自己用的到的部分。不要直接复制。 Anish 的配置文件 Jon (uses neovim) 的配置文件 Jose 的配置文件 下面提供一个文档详细的基本设置，你可以用它当作你的初始设置。我们推荐使用这个设置因为它修复了一些 Vim 默认设置奇怪行为。将其复制粘贴保存为 ~/.vimrc。 \" Vimscript 中的注释以 `\"` 开头。 \" 如果您在 Vim 中打开此文件，它将为您突出显示语法。 \" Vim 是基于 Vi 的。设置 `noknown` 会切换默认的 Vi 兼容模式并启用有用的 Vim 功能。 \" 对于名为 '~/.vimrc' 的文件来说，这个配置选项不是必需的，因为 Vim 会自动输入 noknown \" 如果该文件存在，则我们将其包含在此处，以防万一该配置文件以其他方式加载 \" （例如保存为 `foo`，然后 Vim 以 `vim -u foo` 启动）。 set nocompatible \" 打开语法高亮。 syntax on \" 禁用默认的 Vim 启动消息。 set shortmess+=I \" 显示行号。 set number \" 这将启用相对行编号模式。同时启用 number 和relativenumber 后，当前行显示真实行号， \" 而所有其他行（上方和下方）均相对于当前行进行编号。这很有用，因为您可以知道， \" 一目了然，需要多少次才能向上或向下跳转到特定行，通过 {count}k 向上或通过 {count}j 向下。 set relativenumber \" 即使只打开一个窗口，也始终在底部显示状态行。 set laststatus=2 \" 默认情况下，退格键的行为有点不直观。 \" 例如，默认情况下，您无法在用“i”设置的插入点之前退格。 \" 此配置使退格键的行为更加合理，因为您可以在任何东西上退格。 set backspace=indent,eol,start \" 默认情况下，Vim 不允许您隐藏具有未保存更改的缓冲区（即具有未在任何窗口中显示的缓冲区）。 \" 这是为了防止您 \" 忘记未保存的更改然后退出，例如 通过`:qa!`。 \" 我们发现隐藏缓冲区足以帮助禁用此保护。 有关详细信息，请参阅“:helphidden”。 set hidden \" 当要搜索的字符串中的所有字符均为小写时，此设置使搜索不区分大小写。 \" 但是，如果包含任何大写字母，则搜索将区分大小写。这使搜索更加方便。 set ignorecase set smartcase \" 在键入时启用搜索，而不是等到按 Enter 键。 set incsearch \" 取消绑定一些无用/烦人的默认按键绑定。 \" 'Q' 在正常模式下进入 Ex 模式。你几乎永远不会想要这个。 nmap Q \u003cNop\u003e \" 'Q' in normal mode enters Ex mode. You almost never want this. \" 禁用声音铃声，因为它很烦人。 set noerrorbells visualbell t_vb= \" 启用鼠标支持。您应该避免过度依赖它，但有时它很方便。 set mouse+=a \" 尽量避免使用方向键进行移动等坏习惯。这并不是唯一可能的坏习惯。 \" 例如，按住 h/j/k/l 键进行移动，而不是使用更高效的移动命令，也是一种可能的坏习惯。 \" 前者可以通过 .vimrc 强制执行，而我们不知道如何防止后者。 \" 在正常模式下执行此操作... nnoremap \u003cLeft\u003e :echoe \"Use h\"\u003cCR\u003e nnoremap \u003cRight\u003e :echoe \"Use l\"\u003cCR\u003e nnoremap \u003cUp\u003e :echoe \"Use k\"\u003cCR\u003e nnoremap \u003cDown\u003e :echoe \"Use j\"\u003cCR\u003e \" ...并在插入模式下执行此操作 inoremap \u003cLeft\u003e \u003cESC\u003e:echoe \"Use h\"\u003cCR\u003e inoremap \u003cRight\u003e \u003cESC\u003e:echoe \"Use l\"\u003cCR\u003e inoremap \u003cUp\u003e \u003cESC\u003e:echoe \"Use k\"\u003cCR\u003e inoremap \u003cDown\u003e \u003cESC\u003e:echoe \"Use j\"\u003cCR\u003e ","date":"2023-07-04","objectID":"/missing-semester-note-1/:5:1","tags":["学习"],"title":"计算机教育中缺失的一课 笔记一","uri":"/missing-semester-note-1/"},{"categories":["笔记"],"content":"扩展你的 Vim —— 插件的使用 Vim 从 8.0 开始有了内置的插件管理器。只需要创建一个 ~/.vim/pack/vendor/start/ 的文件夹，然后把插件放到这里即可。至于插件的选择，可以到 Vim Awesome 去浏览并尝试一下。 Vim Awesome 同时，授课讲师们也推荐了一些插件： ctrlp.vim 模糊文件查找 ack.vim 代码搜索 nerdtree 文件浏览器 vim-easymotion 魔术操作 或者去网路上查找一些博客、文章、回答，关键词是 “best Vim plugins”，当然之前去大佬的配置文件中看看也不失为一个好办法。 ","date":"2023-07-04","objectID":"/missing-semester-note-1/:5:2","tags":["学习"],"title":"计算机教育中缺失的一课 笔记一","uri":"/missing-semester-note-1/"},{"categories":["笔记"],"content":"万物皆可 Vim —— 其他程式的 Vim 模式 Shell Bash 用户，用 set -o vi。 Zsh：bindkey -v。 Fish 用 fish_vi_key_bindings。 另外，不管利用什么 shell，你可以 export EDITOR=vim。 这是一个用来决定当一个程序需要启动编辑时启动哪个的环境变量。 例如，git 会使用这个编辑器来编辑 commit 信息。 浏览器 甚至有 Vim 的网页浏览快捷键 browsers Google Chrome 的 Vimium Firefox 的 Tridactyl 这个列表 中列举了支持类 vim 键位绑定的软件 ","date":"2023-07-04","objectID":"/missing-semester-note-1/:5:3","tags":["学习"],"title":"计算机教育中缺失的一课 笔记一","uri":"/missing-semester-note-1/"},{"categories":["笔记"],"content":"扩展资料 vimtutor 是一个 Vim 安装时自带的教程 Vim Adventures 是一个学习使用 Vim 的游戏 Vim Tips Wiki Vim Advent Calendar 有很多 Vim 小技巧 Vim Golf 是用 Vim 的用户界面作为程序语言的 code golf Vi/Vim Stack Exchange Vim Screencasts Practical Vim（书籍） ","date":"2023-07-04","objectID":"/missing-semester-note-1/:6:0","tags":["学习"],"title":"计算机教育中缺失的一课 笔记一","uri":"/missing-semester-note-1/"},{"categories":["笔记"],"content":"前言 MI 9 最近突发恶疾，每天都会突然黑屏，开机卡 MIUI 界面，LOG 还变黄，经常需要多次尝试不同姿势重启才能开机，就把已经用了万年的 MIUI 10 更新到了 MIUI 12，但遗憾的是更新了以后故障依旧。百度了一下，可能是烧了什么芯片或者 CPU 电源管理芯片虚焊。遂决定喜迎新机，毕竟 MI 9 陪伴我也有 4 年了。既然 MI 9 闲下来了，准备解锁刷个 ROM。先玩着，等故障发生比较频繁了去售后看看能不能修。 在大佬指点和百度下选择了 Pixel Experience 系统，顺便 root 了，装上 Magisk 和 LSPosed。 本文整理记录一下大致过程，只供参考，如果对您有帮助那就太好了。 ","date":"2023-04-14","objectID":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/:1:0","tags":["杂项"],"title":"MI9 Pixel Experience + Magisk","uri":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/"},{"categories":["笔记"],"content":"文件 ├─Apk │ │ FoxMMM-v1.1.0-default-arm64-v8a-release.apk │ │ MT2.13.3-CoolApk-21048-o_1grsjcuebsig1bdl1g4jvmq1cgp13-uid-394584.apk │ │ │ ├─Magisk │ │ │ Magisk-v26.1.apk │ │ │ │ │ └─Mode │ │ CustomPinyinDictionary_Gboard_Magisk_20230413.zip │ │ Font_Manager-v5.7.6-127.zip │ │ LSPosed-v1.8.6-6712-zygisk-release.zip │ │ Shamiko-v0.7-161-release.zip │ │ │ └─Sufboard │ mobile-arm64-v8a-release.apk │ smallstrawberry.conf │ ├─Image │ │ cepheus_eea_global_images_V12.5.2.0.RFAEUXM_20211112.0000.00_11.0_eea_655e654e8a.tgz # EU版MIUI │ │ cepheus_images_V12.5.6.0.RFACNXM_20211125.0000.00_11.0_cn_8d261e6804.tgz # 国行版MIUI │ │ PixelExperience_cepheus-13.0-20221127-0218-OFFICIAL.zip # PixelExperience │ │ xiaomi.eu_multi_MI9_V12.5.6.0.RFACNXM_v12-11.zip # EU版MIUI │ │ │ └─Recovery │ PixelExperience_cepheus-13.0-20221127-0218-OFFICIAL.img # PixelExperience配套rec │ twrp-3.5.2_9-0-cepheus.img # 第三方rec │ └─Tools MiFlash2020-3-14-0.rar # XIAOMI 线刷工具 miflash_unlock-6.5.406.31.zip # XIAOMI 解锁工具（这里面自带 Fastboot） platform-tools_r34.0.1-windows.zip # ADB ","date":"2023-04-14","objectID":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/:2:0","tags":["杂项"],"title":"MI9 Pixel Experience + Magisk","uri":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/"},{"categories":["笔记"],"content":"过程 ","date":"2023-04-14","objectID":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/:3:0","tags":["杂项"],"title":"MI9 Pixel Experience + Magisk","uri":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/"},{"categories":["笔记"],"content":"解锁 Bootloader 小米手机解锁需要小米账号，和小米官方的解锁工具。 MIUI 解锁工具 手机需要登录小米账号并在有 SIM 卡的情况下使用数据流量在“设置 -\u003e 开发者选项 -\u003e 设备解锁状态”中绑定设备。 注意事项： 去 “我的设备 -\u003e 全部参数” 重复点击 “MIUI 版本” 开启开发者模式。 MI 9 进入 Fastboost 方式：关机后，同时按住电源键和音量键下直到出现 “MI” 标志。 如果提示因为账号问题无法解锁，只能等待限制时间到期，或者更换账号。 解锁完毕后，及时退出手机的小米账号和谷歌账号。 ","date":"2023-04-14","objectID":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/:3:1","tags":["杂项"],"title":"MI9 Pixel Experience + Magisk","uri":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/"},{"categories":["笔记"],"content":"重新刷入国行 MIUI 中间我直接清空了所有分区装上了 Pixel Experience 发现有一些问题，百度了一下决定先重新刷个 MIUI，开始刷了 EU 版 MIUI 好多系统软件没有懒得搞其他的了，于是又重新刷了国行包。 去小米官方网站下载线刷工具在以下网站查找 MI 9（需要代理到国外访问） https://c.mi.com/global/miuidownload/index 找到“MI 9 -\u003e Flashing Guide -\u003e Fastboot Update -\u003e Download MIUI ROM Flashing Tool(Size: 66.7 MB)” MIUI ROM Flashing Tool 下载 在 XiaomiROM 直接搜索小米 9 (cepheus)下载国行线刷包。 XiaomiROM 网站 开始刷机，提前退出小米账号和谷歌账号。 运行 XiaoMiFlash.exe -\u003e 手机进入 Fastboost 模式 -\u003e 手机插入电脑- \u003e 点击Driver -\u003e 点击安装（默认把所有需要的驱动装入电脑） 回到 XiaoMiFlash 首页 -\u003e 点击选择 -\u003e 选择解压的文件夹 -\u003e 点击加载设备 -\u003e 点击加载出的设备 -\u003e 点击右下角全部删除 -\u003e 刷机 一定要选择“全部删除”，默认是删除加锁。 稍作等待，刷完后将小米的系统软件全部安装更新一遍，更新完毕后退出小米账号即可。 ","date":"2023-04-14","objectID":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/:3:2","tags":["杂项"],"title":"MI9 Pixel Experience + Magisk","uri":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/"},{"categories":["笔记"],"content":"刷入 Pixel Experience 到 Pixel Experience 官网，点击 devices 按照机型查找相关 ROM。 Pixel Experience 官网 Pixel Experience 官网 - Xiaomi Mi 9 选择最新的版本（13）将镜像和 Recovery 都下载下来。 使用 Fastboot 安装 Pixel Experience Recovery Pixel Experience Recovery 是第三方（非小米）的恢复程序。在这里使用这个配套刷入系统。 手机进入 Fastboot 模式（电源键 + 音量下）并将手机与电脑连接，将 Pixel Experience Recovery 放到和 fastboot 工具一个目录下，输入命令： .\\fastboot.exe flash recovery PixelExperience_cepheus-13.0-20221127-0218-OFFICIAL.img fastboot 工具在 XIAOMI 的解锁工具里有，我直接在解锁工具的目录里用的。 从 Recovery 安装Pixel Experience MI 9 进入 Recovery 方式：关机后，同时按住电源键和音量键上直到出现 “MI” 标志。 进入 Recovery 点击 Factory Reset ，然后点击 Format data/ 格式化数据分区。 格式化完成后点击左上角返回按钮，返回到主菜单，点击 Apply from ADB 并将手机与电脑连接。 电脑下载 ADB 工具。 Android SDK Platform-Tools 是 Android SDK 的一个组件。它包含与 Android 平台进行交互的工具，主要是 adb 和 fastboot。 ANDROID STUDIO SDK 平台工具 在电脑上，将 Pixel Experience 包放到ADB 工具的目录下，使用命令： ./Adb sideload PixelExperience_cepheus-13.0-20221127-0218-OFFICIAL.zip **提示：**通常情况下，adb 会报告Total xfer: 1.00x，但在某些情况下，即使进程成功，输出也会停止在 47% 并报告Total xfer: 0.98xor adb: failed to read command: Success。在某些情况下，它会报告adb: failed to read command: No errororadb: failed to read command: Undefined error: 0也可以。 然后解决一下开机启用页面设置，连接 WIFI 无法跳过的问题，输入命令修改 FRP 标志位： ./Adb shell dd if=/dev/zero of=/dev/block/bootdevice/by-name/frp 等待完成后，手机返回到主菜单，点击 Reboot system now 即可。 重启之后，成功进入系统开始设置。 ","date":"2023-04-14","objectID":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/:3:3","tags":["杂项"],"title":"MI9 Pixel Experience + Magisk","uri":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/"},{"categories":["笔记"],"content":"安装 Magisk 先到 GitHub 下载最新的 Magisk（记录时最新版本为 v26.1）。 Magisk - GitHub 手机安装一下，完成后进去，Ramdisk 已经是 Yes 了，接下来修补一下 boot.img。 boot.img 从 PixelExperience_cepheus-13.0-20221127-0218-OFFICIAL.zip，解压出来即可。 将 boot.img 放到手机中，在 Magisk 的主页面的 Magisk（也就是第一个）选择 Install，方式为 选择并修补一个文件，选择刚刚放进去的 boot.img 选中，完成后重启。 重启后就可以设置 Magisk 并继续安装 LSPosed 等等了。 ","date":"2023-04-14","objectID":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/:3:4","tags":["杂项"],"title":"MI9 Pixel Experience + Magisk","uri":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/"},{"categories":["笔记"],"content":"写在末尾 过程基本就是这样，接下来看看有什么模块比较好用有意思来试一试了。 ","date":"2023-04-14","objectID":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/:4:0","tags":["杂项"],"title":"MI9 Pixel Experience + Magisk","uri":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/"},{"categories":["笔记"],"content":"参考链接 https://zhuanlan.zhihu.com/p/408114647 https://wiki.pixelexperience.org/devices/cepheus/install/ https://topjohnwu.github.io/Magisk/install.html ","date":"2023-04-14","objectID":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/:5:0","tags":["杂项"],"title":"MI9 Pixel Experience + Magisk","uri":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/"},{"categories":["笔记"],"content":"附录 https://github.com/LSPosed/LSPosed https://github.com/wuhgit/CustomPinyinDictionary https://github.com/Fox2Code/FoxMagiskModuleManager https://github.com/DJ131452DJ/Shamiko_for_Magisk ","date":"2023-04-14","objectID":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/:6:0","tags":["杂项"],"title":"MI9 Pixel Experience + Magisk","uri":"/mi9%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8C%97/"},{"categories":["笔记"],"content":"前言 我对于docker一直有断断续续的使用，但仅限于用 docker hub 寻找漏洞环境，简单的拉取和使用，搭起来博客之后，想来多少应该写点什么，正好在学校“坐牢”的日子里有云计算的大佬玩 k8s 引起一些兴趣，同时有重头系统的学习一些知识的打算，便决定从 docker 的使用开始，顺便搭几个靶场环境，方便学习。 最重要的是做一些简单的摘抄和记录，以供后面翻阅参考，摆脱之前东一榔头西一棒槌的学习模式。接下来记录的内容中有关 Docker 的，主要是 Docker-从入门到实践 的内容，外加其他一些博客等，此外感谢给予指导的大佬们的支持。 ","date":"2022-07-18","objectID":"/2022071801/:1:0","tags":["Docker","学习"],"title":"Docker 笔记（一）","uri":"/2022071801/"},{"categories":["笔记"],"content":"Docker 的简单介绍 Docker 是一个开源的应用容器引擎，基于 Go语言开发，使用Linux内核相关技术，对进程进行分装隔离，属于操作系统层面的虚拟化技术，应用了沙箱的机制，相互之间没有任何接口。 ","date":"2022-07-18","objectID":"/2022071801/:2:0","tags":["Docker","学习"],"title":"Docker 笔记（一）","uri":"/2022071801/"},{"categories":["笔记"],"content":"Docker 的三个基本概念 ","date":"2022-07-18","objectID":"/2022071801/:3:0","tags":["Docker","学习"],"title":"Docker 笔记（一）","uri":"/2022071801/"},{"categories":["笔记"],"content":"镜像（Image） Docker 镜像是一个特殊的文件系统包含一些为运行准备的配置参数，但不包含任何动态数据，其内容在构建之后也不会被改变。 镜像的多层特性 严格来说，Docker 镜像并不是 ISO 那样的打包文件，而只是一个虚拟的概念，是由一组文件系统在多层上联合组成。Docker 镜像在构建时会一层层构建，前一层是后一层的基础。每一层构建完成后就不会再改变，哪怕是对上一层进行删改，也仅仅只是在当前层进行标记。 也就是说每一层在确定构建完全之前，一定要确认只包含了必要的东西。 镜像的体积 docker 镜像的体积，在仓库中一般显示的是压缩后的大小，而拉取到本地后检视的则是展开的大小。值得注意的是，由于 Docker 镜像是多层存储结构，并可以继承、复用，因此不同镜像可以使用相同的基础镜像，这样一来显示镜像占用的硬盘大小的总和一般比实际要小的多。 要想列出已经下载下来的镜像，可以使用 docker image ls 命令。列表包含了仓库名、标签、镜像 ID、创建时间以及所占用的空间。 运行命令出现镜像仓库名和标签均为 \u003cnone\u003e 的情况，这是虚悬镜像 (dangling image) ，可以使用 docker image ls -f dangling=true 来查看，一般这种镜像是因为，官方对镜像进行了维护，镜像名被转移到新的镜像去了，可以使用命令 docker image prune 删除。 中间层镜像 中间层镜像可以加速构建重复利用资源，命令 docker image ls 默认只会显示顶层镜像，如果希望显示可以加 -a 参数。使用后可以看到许多无标签的镜像，但与虚悬镜像不同，不可以随意删除，因为中间层镜像是别的镜像的依赖，同时相同的层在 Docker 中只会保存一遍，对空间占用影响不大。 删除镜像时的两个行为 删除本地的镜像，使用 docker image rm 命令，Docker 镜像的删除行为分两类： Untagged 取消标签 Deleted 删除镜像 前面我们知道了，镜像是分层的，而且中间层可以被多个镜像使用。所以在进行删除行为时，会先从上层向基础层依次取消每层的标签，并判断取消后没有其他标签后才会执行删除。也就是说并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。 除镜像的依赖之外，还要注意有没有容器对要删除的镜像有依赖，毕竟容器是以镜像为基础，再加一层容器存储层去运行的。 镜像的构成与定制 Dockerfile 文件 Dockerfile 文件中包含一条条指令，文件用来构建镜像，每一条构建一层。 通过 FROM 指定一个基础镜像，并且必须是第一条指令，有一个特殊镜像 scratch ，这个镜像是虚拟的概念，表示空白。 通过 RUN 来执行命令，有 shell 格式 RUN \u003c命令\u003e 和 exec 格式 RUN [\"可执行文件\", \"参数1\", \"参数2\"] 这种更像是函数调用的格式。值得注意的是，执行命令每一条就代表构建一层镜像，构建命令时可可以用 \u0026\u0026 来串联起多条语句，同时最后一定要进行清理无关文件等操作。 #FROM 指定基础镜像 FROM debian:stretch #RUN 执行命令 RUN apt-get update \\ \u0026\u0026 apt-get purge -y --auto-remove $buildDeps commit 与 build 构建命令 命令 docker commit [选项] \u003c容器ID或容器名\u003e [\u003c仓库名\u003e[:\u003c标签\u003e]] 用来生成黑箱镜像，也就是将容器的存储层保存下来成为镜像，但这种方法只适用于入侵后保存现场等特殊情况，因为他不像使用 Dockerfile 文件进行构建，容器内执行过什么命令进行过什么操作没有直观记录，而且容器内的修改调试，有大量重复臃肿的内容，通过 commit 构建之后，不仅大小会大很多，而且因为具体操作不清晰，对后期的维护十分不便。 命令 docker build [选项] \u003c上下文路径/URL/-\u003e 可以使用 Dockerfile 文件来构建镜像， 最后的上下文路径要注意，为相对路径，一般来说，把需要构建入镜像的文件放到 Dockerfile 所在目录，用 . 表示为当前目录。docker build 还支持从 URL 构建，比如通过 Git repo、压缩包等。 ","date":"2022-07-18","objectID":"/2022071801/:3:1","tags":["Docker","学习"],"title":"Docker 笔记（一）","uri":"/2022071801/"},{"categories":["笔记"],"content":"容器（Container） 在 Docker 中，镜像与容器的关系，镜像是静态的定义，容器是镜像运行时的实体。容器的实质是进程，这里有一个新的名词“命名空间”。在容器进程运行时属于自己的独立的命名空间。 命名空间是Linux内核的一项功能，可以对内核资源进行分区，以便一组进程看到一组资源，而另一组进程看到另一组资源。 同样的，容器也是分层存储的，在运行时，以镜像为基础层，在其上创建容器存储层。容器存储层的生存周期和容器一样，容器消亡时也随之消亡。最好来说，容器存储层要保持无状态化，也就是不写入任何数据。所有的文件操作，都应该使用数据卷或绑定宿主目录，在这些位置操作会跳过容器存储层。 数据卷 (Volume) 的生存周期独立于容器，容器消亡，数据卷不会消亡。 容器的启动-运行-终止 ","date":"2022-07-18","objectID":"/2022071801/:3:2","tags":["Docker","学习"],"title":"Docker 笔记（一）","uri":"/2022071801/"},{"categories":["笔记"],"content":"仓库（Repository） Docker Registry 是一个集中存储、分发镜像的服务。一个 Docker Registry 中可以包含多个仓库 (Repository)；每个仓库有多个标签 (Tag)；每个标签对应一个镜像。通过格式 \u003c仓库名\u003e:\u003c标签\u003e 来指定具体这个软件的那个版本的镜像。latest 为默认标签。 有官方和第三方提供的免费或者收费相关服务，也可以通过 Docker 官方提供的镜像，在本地搭建私有 Docker Registry。 Docker 官方 Registry 公开服务 Docker hub 使用 Docker 镜像 ","date":"2022-07-18","objectID":"/2022071801/:3:3","tags":["Docker","学习"],"title":"Docker 笔记（一）","uri":"/2022071801/"},{"categories":["随笔"],"content":"​ 《我们生活在南京》走到了尾声，压抑中带有一丝平淡，人生也就是这样，终得一死，连翘还需要背负着”老师“之名等待半夏的到来，那枚摩斯码练习币将穿越时间和苦痛的长河见证整篇故事。 我们怀念一切，希望不只是因为”刀客“的到来。而是人性中美好的部分如同星光点缀的夜空，不是因为光亮，是因为漆黑的夜空而让人记忆深刻。 ICOM725\r","date":"2022-07-10","objectID":"/first_post/:0:0","tags":["读后感"],"title":"2022年的开始","uri":"/first_post/"},{"categories":null,"content":"关于我 胖子 总体能力平均以下 懂一点点网络（基本忘光） 懂一点点安全（皮毛而已） 大专生（毕业了） 本科生 最后，昵称的来源： 《初凉》 [宋] 吴可 初凉宜夜透衣罗，时见流星度绛河。 渐觉露漙金掌重，梧桐影外月明多。 为什么 记录学习生活，最大努力争取更好的自己。 日志 2022.07 初次建立，但没写啥东西。 2023.04 重新搭建了一遍，争取坚持写点东西。 - 73 -\r本 Blog 由 Hugo 强力驱动 | 主题 - FixIt ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]